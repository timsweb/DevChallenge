<div class="container">
    <div class="jumbotron">
        <h1>Welcome</h1>
        <p>
            Welcome to Tim's Developer challenge. Feel free to hack this apart, fix bugs, and do whatever you see fit.
        </p>
    </div>

    <h2>Background</h2>
    <p>This application is built using the Slim PHP framework. It's very basic and light weight. It uses bootstrap for it's (minimal) UI, and there's not a lot else.</p>
    <p>It's deliberatly tiny so there's no additional requirements to run. All you should need is PHP's built in http server.</p>

    <h2>The Task</h2>
    <p>Sometimes we want to ratelimit certain activities on our website. For example, we limit login attempts such that a user's account gets locked for a period of time
    if too many failed login attempts happen in quick succession. Or we might want to throttle an API we host to stop a single user using up too much resource. There are 
    many different algorithms and rules for deciding how we limit those activities. </p>

    <p><strong>We want you to implement a variation of the <a href="https://en.wikipedia.org/wiki/Leaky_bucket" target="_blank">Leaky Bucket Algorithm</a>.</strong></p>

    <p>Wikipedia makes it sound really complicated, but simplly put: the algorithm is based on the analogy where a bucket has a hole in the bottom from which water leaks 
    out at a constant rate. Water can be added to the bucket intermittently, but if too much water is added at once or if water is added at too high an average rate, the
    water will exceed the capacity of the bucket.</p>

    <p>Imagine that the bucket represents the maximum request quota, which is the maximum number of requests you can make at
    one time. The hole in the bucket represents the restore rate, which is the amount of time it takes to be able to make new
    requests. So, if you submit too many requests at once, then the bucket overflows and, in the case of this challenge, throttling occurs. If you fill up the bucket, it takes some time before you
    can add more water to the bucket since the water leaks from the bucket at a steady rate. So the ability to submit more
    requests after you have reached the maximum request quota is governed by the restore rate, the time it takes to allow you to make new requests.
    </p>

    <p>Look at the contents of the &quot;src/Challenge/Throttle&quot; folder. You can see there is already some code in place that handles throttling. What isn't there 
    however is an implementation of the 'StoreageInterface' or the 'LeakyBucket' rule. You will need to create these. The DI container (&quote;src/dependencies.php&quote;)
    is looking for a class called &quot;src/Challenge/Throttle/Storage/SessionStoreage&quot;. This suggests you may want to use $_SESSION for that part.
    </p>

    <p>
        The implementation of the rule is up to you, but again the DI container already has some expectations around this.
    </p>

    <p>When done, zip up your project folder and send it over.</p>

    <div class="center-block">
        <a href='<?=$nextUrl?>' class="btn btn-default">Go have a play</a>
    </div>
</div>
